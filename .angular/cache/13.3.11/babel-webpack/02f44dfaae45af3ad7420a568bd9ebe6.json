{"ast":null,"code":"import { InjectionToken, Injectable, Inject, Optional, VERSION, Component, NgModule } from '@angular/core';\nimport { Location, DOCUMENT, CommonModule } from '@angular/common';\nimport { WrapperSKU, InteractionStatus, EventMessageUtils, InteractionType, BrowserConfigurationAuthError, UrlString, BrowserUtils, StringUtils, NavigationClient } from '@azure/msal-browser';\nimport { from, ReplaySubject, Subject, BehaviorSubject, of, EMPTY } from 'rxjs';\nimport { Router } from '@angular/router';\nimport { map, concatMap, catchError, switchMap, take, filter } from 'rxjs/operators';\nimport { __awaiter } from 'tslib';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nimport * as ɵngcc2 from '@angular/router';\nconst MSAL_INSTANCE = new InjectionToken(\"MSAL_INSTANCE\");\nconst MSAL_GUARD_CONFIG = new InjectionToken(\"MSAL_GUARD_CONFIG\");\nconst MSAL_INTERCEPTOR_CONFIG = new InjectionToken(\"MSAL_INTERCEPTOR_CONFIG\");\nconst MSAL_BROADCAST_CONFIG = new InjectionToken(\"MSAL_BROADCAST_CONFIG\");\n\n/* eslint-disable header/header */\nconst name = \"@azure/msal-angular\";\nconst version = \"2.5.5\";\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nlet MsalService = /*#__PURE__*/(() => {\n  class MsalService {\n    constructor(instance, location) {\n      this.instance = instance;\n      this.location = location;\n      const hash = this.location.path(true).split(\"#\").pop();\n      if (hash) {\n        this.redirectHash = `#${hash}`;\n      }\n      this.instance.initializeWrapperLibrary(WrapperSKU.Angular, version);\n    }\n    initialize() {\n      return from(this.instance.initialize());\n    }\n    acquireTokenPopup(request) {\n      return from(this.instance.acquireTokenPopup(request));\n    }\n    acquireTokenRedirect(request) {\n      return from(this.instance.acquireTokenRedirect(request));\n    }\n    acquireTokenSilent(silentRequest) {\n      return from(this.instance.acquireTokenSilent(silentRequest));\n    }\n    handleRedirectObservable(hash) {\n      return from(this.instance.handleRedirectPromise(hash || this.redirectHash));\n    }\n    loginPopup(request) {\n      return from(this.instance.loginPopup(request));\n    }\n    loginRedirect(request) {\n      return from(this.instance.loginRedirect(request));\n    }\n    logout(logoutRequest) {\n      return from(this.instance.logout(logoutRequest));\n    }\n    logoutRedirect(logoutRequest) {\n      return from(this.instance.logoutRedirect(logoutRequest));\n    }\n    logoutPopup(logoutRequest) {\n      return from(this.instance.logoutPopup(logoutRequest));\n    }\n    ssoSilent(request) {\n      return from(this.instance.ssoSilent(request));\n    }\n    /**\n     * Gets logger for msal-angular.\n     * If no logger set, returns logger instance created with same options as msal-browser\n     */\n    getLogger() {\n      if (!this.logger) {\n        this.logger = this.instance.getLogger().clone(name, version);\n      }\n      return this.logger;\n    }\n    // Create a logger instance for msal-angular with the same options as msal-browser\n    setLogger(logger) {\n      this.logger = logger.clone(name, version);\n      this.instance.setLogger(logger);\n    }\n  }\n  MsalService.ɵfac = function MsalService_Factory(t) {\n    return new (t || MsalService)(ɵngcc0.ɵɵinject(MSAL_INSTANCE), ɵngcc0.ɵɵinject(ɵngcc1.Location));\n  };\n  MsalService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MsalService,\n    factory: MsalService.ɵfac\n  });\n  return MsalService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nlet MsalBroadcastService = /*#__PURE__*/(() => {\n  class MsalBroadcastService {\n    constructor(msalInstance, authService, msalBroadcastConfig) {\n      this.msalInstance = msalInstance;\n      this.authService = authService;\n      this.msalBroadcastConfig = msalBroadcastConfig;\n      // Make _msalSubject a ReplaySubject if configured to replay past events\n      if (this.msalBroadcastConfig && this.msalBroadcastConfig.eventsToReplay > 0) {\n        this.authService.getLogger().verbose(`BroadcastService - replayPastEvents set on BroadcastConfig, replaying the last ${this.msalBroadcastConfig.eventsToReplay} events`);\n        this._msalSubject = new ReplaySubject(this.msalBroadcastConfig.eventsToReplay);\n      } else {\n        // Defaults to _msalSubject being a Subject\n        this._msalSubject = new Subject();\n      }\n      this.msalSubject$ = this._msalSubject.asObservable();\n      // InProgress as BehaviorSubject so most recent inProgress state will be available upon subscription\n      this._inProgress = new BehaviorSubject(InteractionStatus.Startup);\n      this.inProgress$ = this._inProgress.asObservable();\n      this.msalInstance.addEventCallback(message => {\n        this._msalSubject.next(message);\n        const status = EventMessageUtils.getInteractionStatusFromEvent(message, this._inProgress.value);\n        if (status !== null) {\n          this.authService.getLogger().verbose(`BroadcastService - ${message.eventType} results in setting inProgress from ${this._inProgress.value} to ${status}`);\n          this._inProgress.next(status);\n        }\n      });\n    }\n  }\n  MsalBroadcastService.ɵfac = function MsalBroadcastService_Factory(t) {\n    return new (t || MsalBroadcastService)(ɵngcc0.ɵɵinject(MSAL_INSTANCE), ɵngcc0.ɵɵinject(MsalService), ɵngcc0.ɵɵinject(MSAL_BROADCAST_CONFIG, 8));\n  };\n  MsalBroadcastService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MsalBroadcastService,\n    factory: MsalBroadcastService.ɵfac\n  });\n  return MsalBroadcastService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nlet MsalGuard = /*#__PURE__*/(() => {\n  class MsalGuard {\n    constructor(msalGuardConfig, msalBroadcastService, authService, location, router) {\n      this.msalGuardConfig = msalGuardConfig;\n      this.msalBroadcastService = msalBroadcastService;\n      this.authService = authService;\n      this.location = location;\n      this.router = router;\n      // Subscribing so events in MsalGuard will set inProgress$ observable\n      this.msalBroadcastService.inProgress$.subscribe();\n    }\n    /**\n     * Parses url string to UrlTree\n     * @param url\n     */\n    parseUrl(url) {\n      return this.router.parseUrl(url);\n    }\n    /**\n     * Builds the absolute url for the destination page\n     * @param path Relative path of requested page\n     * @returns Full destination url\n     */\n    getDestinationUrl(path) {\n      this.authService.getLogger().verbose(\"Guard - getting destination url\");\n      // Absolute base url for the application (default to origin if base element not present)\n      const baseElements = document.getElementsByTagName(\"base\");\n      const baseUrl = this.location.normalize(baseElements.length ? baseElements[0].href : window.location.origin);\n      // Path of page (including hash, if using hash routing)\n      const pathUrl = this.location.prepareExternalUrl(path);\n      // Hash location strategy\n      if (pathUrl.startsWith(\"#\")) {\n        this.authService.getLogger().verbose(\"Guard - destination by hash routing\");\n        return `${baseUrl}/${pathUrl}`;\n      }\n      /*\n       * If using path location strategy, pathUrl will include the relative portion of the base path (e.g. /base/page).\n       * Since baseUrl also includes /base, can just concatentate baseUrl + path\n       */\n      return `${baseUrl}${path}`;\n    }\n    /**\n     * Interactively prompt the user to login\n     * @param url Path of the requested page\n     */\n    loginInteractively(state) {\n      const authRequest = typeof this.msalGuardConfig.authRequest === \"function\" ? this.msalGuardConfig.authRequest(this.authService, state) : Object.assign({}, this.msalGuardConfig.authRequest);\n      if (this.msalGuardConfig.interactionType === InteractionType.Popup) {\n        this.authService.getLogger().verbose(\"Guard - logging in by popup\");\n        return this.authService.loginPopup(authRequest).pipe(map(response => {\n          this.authService.getLogger().verbose(\"Guard - login by popup successful, can activate, setting active account\");\n          this.authService.instance.setActiveAccount(response.account);\n          return true;\n        }));\n      }\n      this.authService.getLogger().verbose(\"Guard - logging in by redirect\");\n      const redirectStartPage = this.getDestinationUrl(state.url);\n      return this.authService.loginRedirect(Object.assign({\n        redirectStartPage\n      }, authRequest)).pipe(map(() => false));\n    }\n    /**\n     * Helper which checks for the correct interaction type, prevents page with Guard to be set as reidrect, and calls handleRedirectObservable\n     * @param state\n     */\n    activateHelper(state) {\n      if (this.msalGuardConfig.interactionType !== InteractionType.Popup && this.msalGuardConfig.interactionType !== InteractionType.Redirect) {\n        throw new BrowserConfigurationAuthError(\"invalid_interaction_type\", \"Invalid interaction type provided to MSAL Guard. InteractionType.Popup or InteractionType.Redirect must be provided in the MsalGuardConfiguration\");\n      }\n      this.authService.getLogger().verbose(\"MSAL Guard activated\");\n      /*\n       * If a page with MSAL Guard is set as the redirect for acquireTokenSilent,\n       * short-circuit to prevent redirecting or popups.\n       */\n      if (typeof window !== \"undefined\") {\n        if (UrlString.hashContainsKnownProperties(window.location.hash) && BrowserUtils.isInIframe() && !this.authService.instance.getConfiguration().system.allowRedirectInIframe) {\n          this.authService.getLogger().warning(\"Guard - redirectUri set to page with MSAL Guard. It is recommended to not set redirectUri to a page that requires authentication.\");\n          return of(false);\n        }\n      } else {\n        this.authService.getLogger().info(\"Guard - window is undefined, MSAL does not support server-side token acquisition\");\n        return of(true);\n      }\n      /**\n       * If a loginFailedRoute is set in the config, set this as the loginFailedRoute\n       */\n      if (this.msalGuardConfig.loginFailedRoute) {\n        this.loginFailedRoute = this.parseUrl(this.msalGuardConfig.loginFailedRoute);\n      }\n      // Capture current path before it gets changed by handleRedirectObservable\n      const currentPath = this.location.path(true);\n      return this.authService.handleRedirectObservable().pipe(concatMap(() => {\n        if (!this.authService.instance.getAllAccounts().length) {\n          if (state) {\n            this.authService.getLogger().verbose(\"Guard - no accounts retrieved, log in required to activate\");\n            return this.loginInteractively(state);\n          }\n          this.authService.getLogger().verbose(\"Guard - no accounts retrieved, no state, cannot load\");\n          return of(false);\n        }\n        this.authService.getLogger().verbose(\"Guard - at least 1 account exists, can activate or load\");\n        // Prevent navigating the app to /#code= or /code=\n        if (state) {\n          /*\n           * Path routing:\n           * state.url: /#code=...\n           * state.root.fragment: code=...\n           */\n          /*\n           * Hash routing:\n           * state.url: /code\n           * state.root.fragment: null\n           */\n          const urlContainsCode = this.includesCode(state.url);\n          const fragmentContainsCode = !!state.root && !!state.root.fragment && this.includesCode(`#${state.root.fragment}`);\n          const hashRouting = this.location.prepareExternalUrl(state.url).indexOf(\"#\") === 0;\n          // Ensure code parameter is in fragment (and not in query parameter), or that hash hash routing is used\n          if (urlContainsCode && (fragmentContainsCode || hashRouting)) {\n            this.authService.getLogger().info(\"Guard - Hash contains known code response, stopping navigation.\");\n            // Path routing (navigate to current path without hash)\n            if (currentPath.indexOf(\"#\") > -1) {\n              return of(this.parseUrl(this.location.path()));\n            }\n            // Hash routing (navigate to root path)\n            return of(this.parseUrl(\"\"));\n          }\n        }\n        return of(true);\n      }), catchError(error => {\n        this.authService.getLogger().error(\"Guard - error while logging in, unable to activate\");\n        this.authService.getLogger().errorPii(`Guard - error: ${error.message}`);\n        /**\n         * If a loginFailedRoute is set, checks to see if Angular 10+ is used and state is passed in before returning route\n         * Apps using Angular 9 will receive of(false) in canLoad interface, as it does not support UrlTree return types\n         */\n        if (this.loginFailedRoute && parseInt(VERSION.major, 10) > 9 && state) {\n          this.authService.getLogger().verbose(\"Guard - loginFailedRoute set, redirecting\");\n          return of(this.loginFailedRoute);\n        }\n        return of(false);\n      }));\n    }\n    includesCode(path) {\n      return path.lastIndexOf(\"/code\") > -1 && path.lastIndexOf(\"/code\") === path.length - \"/code\".length ||\n      // path.endsWith(\"/code\")\n      path.indexOf(\"#code=\") > -1 || path.indexOf(\"&code=\") > -1;\n    }\n    canActivate(route, state) {\n      this.authService.getLogger().verbose(\"Guard - canActivate\");\n      return this.activateHelper(state);\n    }\n    canActivateChild(route, state) {\n      this.authService.getLogger().verbose(\"Guard - canActivateChild\");\n      return this.activateHelper(state);\n    }\n    canLoad() {\n      this.authService.getLogger().verbose(\"Guard - canLoad\");\n      // @ts-ignore\n      return this.activateHelper();\n    }\n  }\n  MsalGuard.ɵfac = function MsalGuard_Factory(t) {\n    return new (t || MsalGuard)(ɵngcc0.ɵɵinject(MSAL_GUARD_CONFIG), ɵngcc0.ɵɵinject(MsalBroadcastService), ɵngcc0.ɵɵinject(MsalService), ɵngcc0.ɵɵinject(ɵngcc1.Location), ɵngcc0.ɵɵinject(ɵngcc2.Router));\n  };\n  MsalGuard.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MsalGuard,\n    factory: MsalGuard.ɵfac\n  });\n  return MsalGuard;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nlet MsalInterceptor = /*#__PURE__*/(() => {\n  class MsalInterceptor {\n    constructor(msalInterceptorConfig, authService, location, msalBroadcastService,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n    document) {\n      this.msalInterceptorConfig = msalInterceptorConfig;\n      this.authService = authService;\n      this.location = location;\n      this.msalBroadcastService = msalBroadcastService;\n      this._document = document;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    intercept(req, next) {\n      if (this.msalInterceptorConfig.interactionType !== InteractionType.Popup && this.msalInterceptorConfig.interactionType !== InteractionType.Redirect) {\n        throw new BrowserConfigurationAuthError(\"invalid_interaction_type\", \"Invalid interaction type provided to MSAL Interceptor. InteractionType.Popup, InteractionType.Redirect must be provided in the msalInterceptorConfiguration\");\n      }\n      this.authService.getLogger().verbose(\"MSAL Interceptor activated\");\n      const scopes = this.getScopesForEndpoint(req.url, req.method);\n      // If no scopes for endpoint, does not acquire token\n      if (!scopes || scopes.length === 0) {\n        this.authService.getLogger().verbose(\"Interceptor - no scopes for endpoint\");\n        return next.handle(req);\n      }\n      // Sets account as active account or first account\n      let account;\n      if (!!this.authService.instance.getActiveAccount()) {\n        this.authService.getLogger().verbose(\"Interceptor - active account selected\");\n        account = this.authService.instance.getActiveAccount();\n      } else {\n        this.authService.getLogger().verbose(\"Interceptor - no active account, fallback to first account\");\n        account = this.authService.instance.getAllAccounts()[0];\n      }\n      const authRequest = typeof this.msalInterceptorConfig.authRequest === \"function\" ? this.msalInterceptorConfig.authRequest(this.authService, req, {\n        account: account\n      }) : Object.assign(Object.assign({}, this.msalInterceptorConfig.authRequest), {\n        account\n      });\n      this.authService.getLogger().info(`Interceptor - ${scopes.length} scopes found for endpoint`);\n      this.authService.getLogger().infoPii(`Interceptor - [${scopes}] scopes found for ${req.url}`);\n      return this.acquireToken(authRequest, scopes, account).pipe(switchMap(result => {\n        this.authService.getLogger().verbose(\"Interceptor - setting authorization headers\");\n        const headers = req.headers.set(\"Authorization\", `Bearer ${result.accessToken}`);\n        const requestClone = req.clone({\n          headers\n        });\n        return next.handle(requestClone);\n      }));\n    }\n    /**\n     * Try to acquire token silently. Invoke interaction if acquireTokenSilent rejected with error or resolved with null access token\n     * @param authRequest Request\n     * @param scopes Array of scopes for the request\n     * @param account Account\n     * @returns Authentication result\n     */\n    acquireToken(authRequest, scopes, account) {\n      // Note: For MSA accounts, include openid scope when calling acquireTokenSilent to return idToken\n      return this.authService.acquireTokenSilent(Object.assign(Object.assign({}, authRequest), {\n        scopes,\n        account\n      })).pipe(catchError(() => {\n        this.authService.getLogger().error(\"Interceptor - acquireTokenSilent rejected with error. Invoking interaction to resolve.\");\n        return this.msalBroadcastService.inProgress$.pipe(take(1), switchMap(status => {\n          if (status === InteractionStatus.None) {\n            return this.acquireTokenInteractively(authRequest, scopes);\n          }\n          return this.msalBroadcastService.inProgress$.pipe(filter(status => status === InteractionStatus.None), take(1), switchMap(() => this.acquireToken(authRequest, scopes, account)));\n        }));\n      }), switchMap(result => {\n        if (!result.accessToken) {\n          this.authService.getLogger().error(\"Interceptor - acquireTokenSilent resolved with null access token. Known issue with B2C tenants, invoking interaction to resolve.\");\n          return this.msalBroadcastService.inProgress$.pipe(filter(status => status === InteractionStatus.None), take(1), switchMap(() => this.acquireTokenInteractively(authRequest, scopes)));\n        }\n        return of(result);\n      }));\n    }\n    /**\n     * Invoke interaction for the given set of scopes\n     * @param authRequest Request\n     * @param scopes Array of scopes for the request\n     * @returns Result from the interactive request\n     */\n    acquireTokenInteractively(authRequest, scopes) {\n      if (this.msalInterceptorConfig.interactionType === InteractionType.Popup) {\n        this.authService.getLogger().verbose(\"Interceptor - error acquiring token silently, acquiring by popup\");\n        return this.authService.acquireTokenPopup(Object.assign(Object.assign({}, authRequest), {\n          scopes\n        }));\n      }\n      this.authService.getLogger().verbose(\"Interceptor - error acquiring token silently, acquiring by redirect\");\n      const redirectStartPage = window.location.href;\n      this.authService.acquireTokenRedirect(Object.assign(Object.assign({}, authRequest), {\n        scopes,\n        redirectStartPage\n      }));\n      return EMPTY;\n    }\n    /**\n     * Looks up the scopes for the given endpoint from the protectedResourceMap\n     * @param endpoint Url of the request\n     * @param httpMethod Http method of the request\n     * @returns Array of scopes, or null if not found\n     *\n     */\n    getScopesForEndpoint(endpoint, httpMethod) {\n      this.authService.getLogger().verbose(\"Interceptor - getting scopes for endpoint\");\n      // Ensures endpoints and protected resources compared are normalized\n      const normalizedEndpoint = this.location.normalize(endpoint);\n      const protectedResourcesArray = Array.from(this.msalInterceptorConfig.protectedResourceMap.keys());\n      const matchingProtectedResources = this.matchResourcesToEndpoint(protectedResourcesArray, normalizedEndpoint);\n      // Check absolute urls of resources first before checking relative to prevent incorrect matching where multiple resources have similar relative urls\n      if (matchingProtectedResources.absoluteResources.length > 0) {\n        return this.matchScopesToEndpoint(this.msalInterceptorConfig.protectedResourceMap, matchingProtectedResources.absoluteResources, httpMethod);\n      } else if (matchingProtectedResources.relativeResources.length > 0) {\n        return this.matchScopesToEndpoint(this.msalInterceptorConfig.protectedResourceMap, matchingProtectedResources.relativeResources, httpMethod);\n      }\n      return null;\n    }\n    /**\n     * Finds resource endpoints that match request endpoint\n     * @param protectedResourcesEndpoints\n     * @param endpoint\n     * @returns\n     */\n    matchResourcesToEndpoint(protectedResourcesEndpoints, endpoint) {\n      const matchingResources = {\n        absoluteResources: [],\n        relativeResources: []\n      };\n      protectedResourcesEndpoints.forEach(key => {\n        // Normalizes and adds resource to matchingResources.absoluteResources if key matches endpoint. StringUtils.matchPattern accounts for wildcards\n        const normalizedKey = this.location.normalize(key);\n        if (StringUtils.matchPattern(normalizedKey, endpoint)) {\n          matchingResources.absoluteResources.push(key);\n        }\n        // Get url components for relative urls\n        const absoluteKey = this.getAbsoluteUrl(key);\n        const keyComponents = new UrlString(absoluteKey).getUrlComponents();\n        const absoluteEndpoint = this.getAbsoluteUrl(endpoint);\n        const endpointComponents = new UrlString(absoluteEndpoint).getUrlComponents();\n        // Normalized key should include query strings if applicable\n        const relativeNormalizedKey = keyComponents.QueryString ? `${keyComponents.AbsolutePath}?${keyComponents.QueryString}` : this.location.normalize(keyComponents.AbsolutePath);\n        // Add resource to matchingResources.relativeResources if same origin, relativeKey matches endpoint, and is not empty\n        if (keyComponents.HostNameAndPort === endpointComponents.HostNameAndPort && StringUtils.matchPattern(relativeNormalizedKey, absoluteEndpoint) && relativeNormalizedKey !== \"\" && relativeNormalizedKey !== \"/*\") {\n          matchingResources.relativeResources.push(key);\n        }\n      });\n      return matchingResources;\n    }\n    /**\n     * Transforms relative urls to absolute urls\n     * @param url\n     * @returns\n     */\n    getAbsoluteUrl(url) {\n      const link = this._document.createElement(\"a\");\n      link.href = url;\n      return link.href;\n    }\n    /**\n     * Finds scopes from first matching endpoint with HTTP method that matches request\n     * @param protectedResourceMap Protected resource map\n     * @param endpointArray Array of resources that match request endpoint\n     * @param httpMethod Http method of the request\n     * @returns\n     */\n    matchScopesToEndpoint(protectedResourceMap, endpointArray, httpMethod) {\n      const allMatchedScopes = [];\n      // Check each matched endpoint for matching HttpMethod and scopes\n      endpointArray.forEach(matchedEndpoint => {\n        const scopesForEndpoint = [];\n        const methodAndScopesArray = protectedResourceMap.get(matchedEndpoint);\n        // Return if resource is unprotected\n        if (methodAndScopesArray === null) {\n          allMatchedScopes.push(null);\n          return;\n        }\n        methodAndScopesArray.forEach(entry => {\n          // Entry is either array of scopes or ProtectedResourceScopes object\n          if (typeof entry === \"string\") {\n            scopesForEndpoint.push(entry);\n          } else {\n            // Ensure methods being compared are normalized\n            const normalizedRequestMethod = httpMethod.toLowerCase();\n            const normalizedResourceMethod = entry.httpMethod.toLowerCase();\n            // Method in protectedResourceMap matches request http method\n            if (normalizedResourceMethod === normalizedRequestMethod) {\n              // Validate if scopes comes null to unprotect the resource in a certain http method\n              if (entry.scopes === null) {\n                allMatchedScopes.push(null);\n              } else {\n                entry.scopes.forEach(scope => {\n                  scopesForEndpoint.push(scope);\n                });\n              }\n            }\n          }\n        });\n        // Only add to all scopes if scopes for endpoint and method is found\n        if (scopesForEndpoint.length > 0) {\n          allMatchedScopes.push(scopesForEndpoint);\n        }\n      });\n      if (allMatchedScopes.length > 0) {\n        if (allMatchedScopes.length > 1) {\n          this.authService.getLogger().warning(\"Interceptor - More than 1 matching scopes for endpoint found.\");\n        }\n        // Returns scopes for first matching endpoint\n        return allMatchedScopes[0];\n      }\n      return null;\n    }\n  }\n  MsalInterceptor.ɵfac = function MsalInterceptor_Factory(t) {\n    return new (t || MsalInterceptor)(ɵngcc0.ɵɵinject(MSAL_INTERCEPTOR_CONFIG), ɵngcc0.ɵɵinject(MsalService), ɵngcc0.ɵɵinject(ɵngcc1.Location), ɵngcc0.ɵɵinject(MsalBroadcastService), ɵngcc0.ɵɵinject(DOCUMENT));\n  };\n  MsalInterceptor.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MsalInterceptor,\n    factory: MsalInterceptor.ɵfac\n  });\n  return MsalInterceptor;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nlet MsalRedirectComponent = /*#__PURE__*/(() => {\n  class MsalRedirectComponent {\n    constructor(authService) {\n      this.authService = authService;\n    }\n    ngOnInit() {\n      this.authService.getLogger().verbose(\"MsalRedirectComponent activated\");\n      this.authService.initialize().pipe(concatMap(() => {\n        return this.authService.handleRedirectObservable();\n      })).subscribe();\n    }\n  }\n  MsalRedirectComponent.ɵfac = function MsalRedirectComponent_Factory(t) {\n    return new (t || MsalRedirectComponent)(ɵngcc0.ɵɵdirectiveInject(MsalService));\n  };\n  MsalRedirectComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MsalRedirectComponent,\n    selectors: [[\"app-redirect\"]],\n    decls: 0,\n    vars: 0,\n    template: function MsalRedirectComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return MsalRedirectComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nlet MsalModule = /*#__PURE__*/(() => {\n  class MsalModule {\n    static forRoot(msalInstance, guardConfig, interceptorConfig) {\n      return {\n        ngModule: MsalModule,\n        providers: [{\n          provide: MSAL_INSTANCE,\n          useValue: msalInstance\n        }, {\n          provide: MSAL_GUARD_CONFIG,\n          useValue: guardConfig\n        }, {\n          provide: MSAL_INTERCEPTOR_CONFIG,\n          useValue: interceptorConfig\n        }, MsalService]\n      };\n    }\n  }\n  MsalModule.ɵfac = function MsalModule_Factory(t) {\n    return new (t || MsalModule)();\n  };\n  MsalModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MsalModule\n  });\n  MsalModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [MsalGuard, MsalBroadcastService],\n    imports: [[CommonModule]]\n  });\n  return MsalModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MsalModule, {\n    declarations: function () {\n      return [MsalRedirectComponent];\n    },\n    imports: function () {\n      return [CommonModule];\n    }\n  });\n})();\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Custom navigation used for Angular client-side navigation.\n * See performance doc for details:\n * https://github.com/AzureAD/microsoft-authentication-library-for-js/tree/dev/lib/msal-angular/docs/v2-docs/performance.md\n */\nlet MsalCustomNavigationClient = /*#__PURE__*/(() => {\n  class MsalCustomNavigationClient extends NavigationClient {\n    constructor(authService, router, location) {\n      super();\n      this.authService = authService;\n      this.router = router;\n      this.location = location;\n    }\n    navigateInternal(url, options) {\n      const _super = Object.create(null, {\n        navigateInternal: {\n          get: () => super.navigateInternal\n        }\n      });\n      return __awaiter(this, void 0, void 0, function* () {\n        this.authService.getLogger().trace(\"MsalCustomNavigationClient called\");\n        this.authService.getLogger().verbose(\"MsalCustomNavigationClient - navigating\");\n        this.authService.getLogger().verbosePii(`MsalCustomNavigationClient - navigating to url: ${url}`);\n        // Prevent hash clearing from causing an issue with Client-side navigation after redirect is handled\n        if (options.noHistory) {\n          return _super.navigateInternal.call(this, url, options);\n        } else {\n          // Normalizing newUrl if no query string\n          const urlComponents = new UrlString(url).getUrlComponents();\n          const newUrl = urlComponents.QueryString ? `${urlComponents.AbsolutePath}?${urlComponents.QueryString}` : this.location.normalize(urlComponents.AbsolutePath);\n          this.router.navigateByUrl(newUrl, {\n            replaceUrl: options.noHistory\n          });\n        }\n        return Promise.resolve(options.noHistory);\n      });\n    }\n  }\n  MsalCustomNavigationClient.ɵfac = function MsalCustomNavigationClient_Factory(t) {\n    return new (t || MsalCustomNavigationClient)(ɵngcc0.ɵɵinject(MsalService), ɵngcc0.ɵɵinject(ɵngcc2.Router), ɵngcc0.ɵɵinject(ɵngcc1.Location));\n  };\n  MsalCustomNavigationClient.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MsalCustomNavigationClient,\n    factory: MsalCustomNavigationClient.ɵfac\n  });\n  return MsalCustomNavigationClient;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MSAL_BROADCAST_CONFIG, MSAL_GUARD_CONFIG, MSAL_INSTANCE, MSAL_INTERCEPTOR_CONFIG, MsalBroadcastService, MsalCustomNavigationClient, MsalGuard, MsalInterceptor, MsalModule, MsalRedirectComponent, MsalService, version };\n\n//# sourceMappingURL=azure-msal-angular.js.map","map":null,"metadata":{},"sourceType":"module"}